/** 
 *   @file modbus.c
 *   @brief ModBus TCP implementation.
 *   @author Bareilles Federico fede@fcaglp.unlp.edu.ar>
 *   @date 05/03/2020
 * 
 *   @copyright (c) Copyright 2020 Federico Bareilles <fede@fcaglp.unlp.edu.ar>.
 *
 *   This program is free software; you can redistribute it and/or
 *   modify it under the terms of the GNU General Public License as
 *   published by the Free Software Foundation; either version 2 of
 *   the License, or (at your option) any later version.
 *     
 *   The author does NOT admit liability nor provide warranty for any
 *   of this software. This material is provided "AS-IS" in the hope
 *   that it may be useful for others.
 *
 *   05/03/2020: Created.
 **/


#include <stdio.h>
#include <string.h>
#include "modbus.h"
#include "my_tcp.h"
#include "huart_tools.h"
#include "my_config.h"
#include "my_ds18b20.h"

#define SWAP16(n) ( ((((uint16_t)(n) & 0xff))  << 8) |\
		    (((uint16_t)(n)  & 0xff00) >> 8) )

#define SWAP32(n) (((((uint32_t)(n) & 0xff))       << 24) | \
                  ((((uint32_t)(n)  & 0xff00))     <<  8) | \
                  ((((uint32_t)(n)  & 0xff0000))   >>  8) | \
                  ((((uint32_t)(n)  & 0xff000000)) >> 24))

/*
  -0: First reference is 0 (PDU addressing) instead 1
  modpoll  10.10.10.167 -p 502  -r 4000 -c 5
  00 01 00 00 00 06 01 03 0f 9f 00 05 
  00 02 00 00 00 06 01 03 0f 9f 00 05 
  00 03 00 00 00 06 01 03 0f 9f 00 05 
  modpoll  10.10.10.167 -p 502  -r 4000 -c 5 -0

  |00 01|00 00|00 06|01||03|0f a0|00 05 
  |00 02|00 00|00 06|01||03|0f a0|00 05 
  |00 03|00 00|00 06|01||03|0f a0|00 05
  |     |     |     |  ||   |     +-     
  |     |     |     |  ||   +-------     
  |     |     |     |  |+-----------     
  |     |     |     |  +------------ End Header MBAP     
  |     |     |     +--------------- Unit Identifier
  |     |     +--------------------- Length: Number of following bytes    
  |     +--------------------------- Protocol Identifier [0:MODBUS]
  +--------------------------------- Transaction Identifier

  3999 = 0x0f9f
  4000 = 0x0fa0

*/


static uint8_t mb_buff[sizeof(MBAP)];
static uint8_t mb_buff_out[MB_BUFF_OUT_LEN];
static MBAP *mb = (MBAP *) mb_buff;

MB_ADDR_MAP *mb_addr_map = (MB_ADDR_MAP *) mb_buff_out;


static int  mb_f3(uint8_t sn)
{
	int ret = 0;
	MBAP_SEND v;
	THER18B20DATA *thd = my_18b20_get_data_p();
	uint16_t addr = MBAP_ADDR(mb);
	int start = 0;
	int i;
	int id = 0;
	v.fc = 3;
	//01 or 02 or 03 or 04
	if ( (state & ST_ADQ_ENABLE) && addr >= MB_START_ADDR &&
	     addr + MBAP_NUM_REG(mb) <= (MB_THER_ADDR + THERM_NUM)) {
		uint8_t *idt =  my_18b20_get_id_table();
		start = (addr - MB_START_ADDR) << 1;
		v.num_bytes = 0;
		for( i = 0; i < MBAP_NUM_REG(mb); i++) {
			if ( (addr+i) == MB_UPTIME_ADDR ) {
				v.num_bytes += 4;
				i++;
				mb_addr_map->uptime = SWAP32(sec_ticks);
			} else if ( (addr+i) == MB_TIME_ADDR ) {
				v.num_bytes += 4;
				i++;
				mb_addr_map->adq_time = SWAP32(adq_time);
			} else if ( (addr+i) >= MB_THER_ADDR ) {
				id = (addr+i)-MB_THER_ADDR;
				v.num_bytes += 2;
				if (thd[idt[id]].valid) {
					mb_addr_map->value[id] = SWAP16(
						(int16_t)
						(thd[idt[id]].value_avg * 100));
					//mb_addr_map->value[id] =
					//	SWAP16(thd[id].val);
				} else
					mb_addr_map->value[id] = SWAP16(-8500);
			}
		}
		mb->h.len_l = v.num_bytes + 3;
		mb->h.len_h = 0;
	} else if ( addr >= MB_SWITCH_ON && /* open/close door */
		    (addr + MBAP_NUM_REG(mb) - 2) <= MB_SWITCH_OFF) {
		uint32_t *valuep = (uint32_t *) mb_addr_map->value;
		start = 8;
		v.num_bytes = 0;
		for( i = 0; i < MBAP_NUM_REG(mb); i++) {
			if ( (addr+i) == MB_SWITCH_ON ) {
				v.num_bytes += 4;
				valuep[0] = SWAP32(door_sw_open_time);
				i++;
			} else if ( (addr+i) == MB_SWITCH_OFF ) {
				v.num_bytes += 4;
				valuep[i>>1] = SWAP32(door_sw_close_time);
				i++;
			}
		}
		mb->h.len_l = v.num_bytes + 3;
		mb->h.len_h = 0;
	} else if ( addr == MB_THER_NUM ) { /* number of thermometers */
		start = 8;
		v.num_bytes = 2;
		mb->h.len_l = v.num_bytes + 3;
		mb->h.len_h = 0;
		mb_addr_map->value[0] = SWAP16(my_18b20_get_number());
	} else if ( addr == MB_UNIT_ID ) { /* Unit ID */
		start = 8;
		v.num_bytes = 2;
		mb->h.len_l = v.num_bytes + 3;
		mb->h.len_h = 0;
		mb_addr_map->value[0] = SWAP16(MNC_GET_ID());
	} else if ( addr >= MB_ID_TABLE &&
		    addr + MBAP_NUM_REG(mb) <= (MB_ID_TABLE + THERM_NUM)) {
		uint8_t *idt =  my_18b20_get_id_table();
		start = 8;
		v.num_bytes = 0;
		for( i = 0; i < MBAP_NUM_REG(mb); i++) {
			id = (addr+i) - MB_ID_TABLE;
			v.num_bytes += 2;
			mb_addr_map->value[id] = SWAP16((int16_t) (idt[id]));
		}
		mb->h.len_l = v.num_bytes + 3;
		mb->h.len_h = 0;

	} else if ( addr == MB_FIRMWARE_ADDR ) {
		start = 8;
		v.num_bytes = 2;
		mb->h.len_l = v.num_bytes + 3;
		mb->h.len_h = 0;
		mb_addr_map->value[0] =  SWAP16(VERSION << 8 | SUBVERSION);
	} else {
		ret = 2; /* ILLEGAL DATA ADDRESS */
		if ( !(state & ST_ADQ_ENABLE) )
			ret = 5;
	}
	if ( MBAP_NUM_REG(mb) != v.num_bytes >> 1 )
		ret = 3; /* ILLEGAL DATA VALUE */
	if ( ret ) {
		v.fc = 0x83;
		v.num_bytes = ret; /* ERROR CODE */
		mb->h.len_l = 3;
		mb->h.len_h = 0;
	}
		
	send(sn, mb_buff, sizeof(MBAP_H) );
	send(sn, (uint8_t*) &v, sizeof(MBAP_SEND) );
	if ( v.fc == 3 )
		send(sn, mb_buff_out + start, v.num_bytes );

	return 0;
}


static int mb_f2(uint8_t sn) //MB_COILS
{
	int ret = 0;
	uint8_t *dout = (uint8_t *) mb_buff_out;
	MBAP_SEND v;

	v.fc = 2;
	if ( MBAP_ADDR(mb) >= MB_COILS &&
	     (MBAP_ADDR(mb) + MBAP_NUM_REG(mb)) <= (MB_COIL7 + 1) ) {
		int mask = (1<<MBAP_NUM_REG(mb)) - 1;
		//((MBAP_NUM_REG(mb)+7)>>3) 
		v.num_bytes = 1;
		*dout = 0;
		if ( HAL_GPIO_ReadPin(DOOR_SW_GPIO_Port, DOOR_SW_Pin) == 1 )
			*dout |= 0x01;
		if ( HAL_GPIO_ReadPin(Clear_GPIO_Port, Clear_Pin) == 0 )
			*dout |= 0x40;

		*dout = *dout >> (MBAP_ADDR(mb)-MB_COILS);
		*dout &= mask;
		mb->h.len_l = v.num_bytes + 3;
		mb->h.len_h = 0;
	} else {
		v.fc = 0x82;
		v.num_bytes = 0; /* FIXME: ERROR CODE */
		mb->h.len_l = 3;
		mb->h.len_h = 0;
	}

	send(sn, mb_buff, sizeof(MBAP_H) );
	send(sn, (uint8_t*) &v, sizeof(MBAP_SEND) );
	if ( v.fc == 2 )
		send(sn, mb_buff_out, v.num_bytes );

	return ret;
}


static uint8_t socket_enables[MAX_SOCKS] = {0,};

int mb_close_clients(void)
{
	int i;
	for ( i = 0; i < MAX_SOCKS; i++ ) {
		if (socket_enables[i]) {
			socket_enables[i] = 0;
			disconnect(i);
		}
	}

	return 0;
}


int mb_run(uint8_t sn, uint16_t port)
{
	int ret = -1;
	uint16_t len;

	if ( tcp_server_run(sn, port) > 0 ) {
		socket_enables[sn] = 1;
		len = recv(sn, mb_buff, sizeof(MBAP) );
		if ( len != (6+MBAP_LEN(mb) ) )
			return -1;
		if ( MBAP_PT_ID(mb) != 0 ||
		     MBAP_UNIT_ID(mb) !=  UNIT_IDENTIFIER )
			return -2;
		if ( len ) {
			//printf("func: %d\n", MBAP_FUNC_CODE(mb));
			if ( MBAP_FUNC_CODE(mb) == 3 )
				ret = mb_f3(sn); /* Read Holding Registers */
			else if ( MBAP_FUNC_CODE(mb) == 2 )
				ret = mb_f2(sn); /* Read Discrete Inputs */
			if ( ret < 0 ) {
				printf("Invalid pk.\r\n");
			}
		}
	}

	return ret;
}


/*

-----------
modpoll -m tcp  192.168.22.235 -p 502 -a 1 -r 3996 -c 1 -t 4:int -i
00 04 00 00 00 07 01 03 04|00 00 08 c7 
[3996]: 2247

-----------
modpoll -m tcp  192.168.22.235 -p 502 -a 1 -r 3998 -c 1 -t 4:int -i
00 06 00 00 00 07 01 03 04|5e 63 e6 0d
[3998]: 1583605261

-----------
modpoll -m tcp  192.168.22.235 -p 502 -a 1 -r 3996 -c 2 -t 4:int -i
                          |           |           |
00 03 00 00 00 0b 01 03 08|00 00 09 4f|5e 63 e6 7b|
[3996]: 2383
[3998]: 1583605371

-----------
modpoll -m tcp  192.168.22.235 -p 502 -a 1 -r 3996 -c 11

                          | uptime    | adq time  | T 01| T 02| T 03| T 04|
                          |       2556| 1583605544| 2612| 2644| 2656| 2650|
00 04 00 00 00 19 01 03 16|00 00 09 fc|5e 63 e7 28|0a 34|0a 54|0a 60|0a 5a|
 T 05| T 06| T 07|.....| T 15|
 2632| 2644|-8500|.....|     |
0a 47|0a 54|de cc|.....|     |

[3996]: 0
[3997]: 2556
[3998]: 24163
[3999]: -6360
[4000]: 2612
[4001]: 2644
[4002]: 2656
[4003]: 2650
[4004]: 2631
[4005]: 2644
[4006]: -8500
-----------

*/
